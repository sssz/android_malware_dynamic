# -*- coding: utf_8 -*-
import json
import os
import shutil
import subprocess
import threading
import time

from django.conf import settings
from django.http import HttpResponseRedirect

from DynamicAnalyzer.tools.webproxy import (
    start_proxy,
    stop_capfuzz,
    start_fuzz_ui,
    get_ca_dir,
)
from DynamicAnalyzer.views.android.avd import (
    avd_load_wait, 
    refresh_avd,
    stop_avd
)
from DynamicAnalyzer.views.android.virtualbox_vm import (
    refresh_vm
)
from DynamicAnalyzer.views.android.shared import (
    connect,
    install_and_run,
    get_res,
    get_identifier,
    wait,
)
from StaticAnalyzer.views.android.manifest_analysis import (
    manifest_data,
    get_manifest
)

from MobSF.utils import getADB

from Analysis_x_logcat.analysis import analysis_x_logcat
from MalwareClassify.predict import model_predict

def start_dm(md5_hash, package, launcher):
    # Start DM
    #stop_capfuzz(settings.PORT)
    toolsdir = os.path.join(
        settings.BASE_DIR, 'DynamicAnalyzer/tools/')  # TOOLS DIR
    adb = getADB(toolsdir)
    if settings.ANDROID_DYNAMIC_ANALYZER == "MobSF_REAL_DEVICE":
        print("\n[INFO] MobSF will perform Dynamic Analysis on real Android Device")
        is_avd = False
    elif settings.ANDROID_DYNAMIC_ANALYZER == "MobSF_AVD":
        # adb, avd_path, reference_name, dup_name, emulator
        is_avd = True
        refresh_avd(adb, settings.AVD_PATH, settings.AVD_REFERENCE_NAME,
                    settings.AVD_DUP_NAME, settings.AVD_EMULATOR)
    else:
        # Refersh VM
        is_avd = False
        refresh_vm(settings.UUID, settings.SUUID, settings.VBOX)
    context = {'md5': md5_hash,
               'pkg': package,
               'lng': launcher,
               'title': 'Start Testing',
               'AVD': is_avd, }
    return context

def get_env(md5_hash, package, launcher):
    base_dir = settings.BASE_DIR
    app_dir = os.path.join(
        settings.UPLD_DIR, md5_hash + '/')  # APP DIRECTORY
    app_file = md5_hash + '.apk'  # NEW FILENAME
    app_path = app_dir + app_file  # APP PATH
    toolsdir = os.path.join(
        base_dir, 'DynamicAnalyzer/tools/')  # TOOLS DIR
    adb = getADB(toolsdir)
    #if settings.ANDROID_DYNAMIC_ANALYZER == "MobSF_AVD":
    #    proxy_ip = '127.0.0.1'
    #else:
    #    proxy_ip = settings.PROXY_IP  # Proxy IP
    #start_proxy(settings.PORT, package)
    # AVD only needs to wait, vm needs the connect function
    try:
        if settings.ANDROID_DYNAMIC_ANALYZER == "MobSF_AVD":
            avd_load_wait(adb)
        else:
            connect(toolsdir)
    except Exception as exp:
        print("\n[WARNING] ADB Load Wait Failed")
        return HttpResponseRedirect('/error/')
    # Change True to support non-activity components
    install_and_run(toolsdir, app_path, package, launcher, True)
    screen_width, screen_width = get_res()
    data = {'ready': 'yes',
            'screen_witdth': screen_width,
            'screen_height': screen_width, }
    return data

def download_logs(adb, download_dir):
    subprocess.call([adb,
                     "-s",
                     get_identifier(),
                     "pull",
                     "/data/data/de.robv.android.xposed.installer/log/error.log",
                     download_dir + "x_logcat_temp.txt"])
    print("\n[INFO] Downloading Droidmon API Monitor Logcat logs")
    return

def getPidByPackage(adb, package):
    params = [adb, "-s", get_identifier(), "shell", "ps"]
    findPid = None
    retry = 0
    while retry < 3 and findPid is None:
        retry = retry + 1
        pid_result = subprocess.check_output(params)
        pid_result = pid_result.split("\n")
        for ps_item in pid_result:
            ps_item = ps_item.strip().split()
            #['u0_a19', '2396', '295', '580112', '51832', 'ffffffff', '94cca347', 'R', 'com.kuxuexi.math.high']
            if(len(ps_item) < 5):
                continue
            pid = ps_item[1]
            packagename = ps_item[-1]
            if(packagename == package):
                findPid = pid
                break
        if findPid is None:
            time.sleep(1)
    if findPid is not None:
        print("package: %s ==> pid: %s"%(package, findPid))
        return findPid
    raise Exception("pid not found by packageName: %s", package)

    raise Exception("pid not found by packageName")

Is_Downloading = True
def download_logs_thread(adb, download_dir, package):
    #change to strace the pid
    '''
        step1: get pid by ps  | grep packageName
        step2: adb shell strace -T -tt -e trace=all -p pid > to windows_file
    '''
    if not os.path.isdir(download_dir):
        os.makedirs(download_dir)

    pid = getPidByPackage(adb, package)
    print("package: %s ==> pid: %s"%(package, pid))


    start_time = time.asctime( time.localtime(time.time()))
    print("strace start at: %s"%start_time)
    params = [adb, "-s", get_identifier(), "shell", "strace", "-T", "-tt", "-e", "trace=all", "-p", pid]
    strace = subprocess.Popen(params, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    strace_file = os.path.join(download_dir, 'systemcall.txt')
    with open(strace_file, 'w') as sc_file:
        try:
            # strace for 60 seconds
            outs, errs = strace.communicate(timeout=60)
        except subprocess.TimeoutExpired:
            strace.kill()
            outs, errs = strace.communicate()
        sinfo = str(outs.read())
        end_time = time.asctime( time.localtime(time.time()))
        print("strace end at: %s"%end_time)
        print("sinfo len: %s"%len(sinfo))
        if(Is_Downloading):
            sc_file.write(sinfo)

    # global Is_Downloading
    # while Is_Downloading:
    #     download_logs(adb, download_dir)
    #     log_path = os.path.join(download_dir, 'x_logcat.txt')
    #     log_temp_path = os.path.join(download_dir, 'x_logcat_temp.txt')
    #     if os.path.exists(log_path):
    #         log_size = os.path.getsize(log_path)
    #         log_temp_size = os.path.getsize(log_temp_path)
    #         if log_size < log_temp_size:
    #             shutil.copy(log_temp_path, log_path)
    #     else:
    #         shutil.copy(log_temp_path, log_path)
    #     os.remove(log_temp_path)
    #     time.sleep(10)
    return

def start_strace(md5_hash, package):
    app_dir = os.path.join(
        settings.UPLD_DIR, md5_hash + '/')  # APP DIRECTORY
    app_file = md5_hash + '.apk'  # NEW FILENAME
    app_path = app_dir + app_file  # APP PATH
    download_dir = app_path + '_info_/'
    
    base_dir = settings.BASE_DIR
    toolsdir = os.path.join(
        base_dir, 'DynamicAnalyzer/tools/')  # TOOLS DIR
    adb = getADB(toolsdir)
    
    # 开启下载 log 线程
    global Is_Downloading
    Is_Downloading = True
    t = threading.Thread(target=download_logs_thread, args=(adb, download_dir, package))
    t.start()
    return t

# monkey script 测试
def monkey_script_test(adb, app_info):
    monkey_script_pattern = '''
    type=user
    count=10
    speed=1.0
    start data >>
    captureDispatchPointer(0,0,0,200,600,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,200,600,1,1,-1,1,1,0,0)
    UserWait(1000)
    captureDispatchPointer(0,0,0,400,600,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,400,600,1,1,-1,1,1,0,0)
    UserWait(1000)
    captureDispatchPointer(0,0,0,600,600,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,600,600,1,1,-1,1,1,0,0)
    UserWait(1000)
    captureDispatchPointer(0,0,0,200,800,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,200,800,1,1,-1,1,1,0,0)
    UserWait(1000)
    captureDispatchPointer(0,0,0,600,1000,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,600,1000,1,1,-1,1,1,0,0)
    UserWait(3000)
    LaunchActivity({packagename}, {mainactivity})
    UserWait(5000)
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    captureDispatchPointer(0,0,0,{screen_x_middle},100,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},100,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},200,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},200,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},300,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},300,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},400,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},400,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},500,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},500,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},600,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},600,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},700,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},700,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},800,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},800,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},900,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},900,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},1000,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},1000,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},1100,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},1100,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},1200,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},1200,1,1,-1,1,1,0,0)
    UserWait(1000)
    captureDispatchPress(4)
    captureDispatchPress(4)
    captureDispatchPress(4)
    '''
    drag_wait = 750
    packagename = app_info['packagename']
    mainactivity = app_info['mainactivity']
    if mainactivity.startswith('.'):
        mainactivity = packagename + mainactivity
    screen_x_right = 750
    screen_y_middle = 640
    screen_x_left = 50
    screen_x_middle = 400
    
    monkey_script_data = monkey_script_pattern.format(drag_wait=drag_wait, 
        packagename=packagename, mainactivity=mainactivity, 
        screen_x_right=screen_x_right, screen_y_middle=screen_y_middle, 
        screen_x_left=screen_x_left, screen_x_middle=screen_x_middle)
    
    UPLOAD_DIR = settings.UPLD_DIR
    monkey_script_file_name = os.path.join(os.path.join(UPLOAD_DIR, app_info['file_md5']), 'monkey_script.txt')
    with open(monkey_script_file_name, 'w') as f:
        f.write(monkey_script_data)
    
    subprocess.call([adb,
                     "-s",
                     get_identifier(),
                     "push",
                     monkey_script_file_name,
                     "/data/local/tmp"])
    subprocess.call([adb,
                     "-s",
                     get_identifier(),
                     "shell",
                     "monkey", "-f", 
                     "/data/local/tmp/monkey_script.txt", "1"])
    print(u'\n[INFO] 跳过初始化界面')
    return

def auto_app_test(app_info):
    base_dir = settings.BASE_DIR
    toolsdir = os.path.join(
        base_dir, 'DynamicAnalyzer/tools/')  # TOOLS DIR
    adb = getADB(toolsdir)

    print(u'\n[INFO] 开始自动化测试...')
    
    # monkey script 测试，用于进入初始化界面
    monkey_script_test(adb, app_info)
    
    packagename = app_info['packagename']
    # monkey 测试，输出太多，重定向输出
    p = subprocess.Popen([adb, '-s', get_identifier(), 'shell', 
                'monkey', '-p', packagename, 
                '--ignore-crashes', '--ignore-timeouts', 
                '--monitor-native-crashes', 
                '-v', '-v', '-v', '300'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    # 设置超时检查
    start_time = time.time()
    while True:
        if p.poll() is not None:
            #useless_out, useless_err = p.communicate()
            break
        if time.time() - start_time > 60:
            p.terminate()
            break
        time.sleep(0.5)
    
    # TODO: 添加其他测试方法
    return

def clean():
    base_dir = settings.BASE_DIR
    toolsdir = os.path.join(
        base_dir, 'DynamicAnalyzer/tools/')  # TOOLS DIR
    adb = getADB(toolsdir)
    
    print("\n[INFO] Stopping ADB")
    subprocess.call([adb,
                     "-s",
                     get_identifier(),
                     "kill-server"])
    # Close VM
    args = [settings.VBOX, 'controlvm', settings.UUID, 'poweroff']
    subprocess.call(args)
    print("\n[INFO] VM Closed")
    return

def auto_dynamic(md5_hash, package, launcher):
    dm_context = start_dm(md5_hash, package, launcher)
    
    env_data = get_env(md5_hash, package, launcher)
    
    download_thread = start_strace(md5_hash, package)
    
    #TODO
    #time.sleep(40)

    app_info = {'packagename': package, 'mainactivity': launcher, 'file_md5': md5_hash}
    auto_app_test(app_info)
    
    #stop_capfuzz(settings.PORT)
    
    global Is_Downloading
    Is_Downloading = False
    download_thread.join()
    
    time.sleep(3)
    clean()
    return

def get_static_info(md5_hash, package, launcher):
    app_dir = os.path.join(
        settings.UPLD_DIR, md5_hash + '/')  # APP DIRECTORY
    app_file = md5_hash + '.apk'  # NEW FILENAME
    app_path = app_dir + app_file  # APP PATH
    tools_dir = os.path.join(settings.BASE_DIR, 'StaticAnalyzer/tools/')  # TOOLS DIR
    
    # Manifest XML
    manifest_xml = get_manifest(app_path, app_dir, tools_dir, '', True)
    app_info = manifest_data(manifest_xml)
    app_info['packagename'] = package
    app_info['mainactivity'] = launcher
    app_info['file_md5'] = md5_hash

    return app_info

def data_convert(md5_hash, package, launcher):
    print("\n[INFO] Start data convert...")

    app_dir = os.path.join(
        settings.UPLD_DIR, md5_hash + '/')  # APP DIRECTORY
    app_file = md5_hash + '.apk'  # NEW FILENAME
    app_path = app_dir + app_file  # APP PATH
    download_dir = app_path + '_info_/'
    
    app_info = get_static_info(md5_hash, package, launcher)

    result = analysis_x_logcat(download_dir + 'x_logcat.txt', app_info)
    print(u'分析结果目录：', download_dir)
    data_path = download_dir + 'x_logcat.txt' + '_timeflow_list.json' + '.npy'
    print(u'npy文件路径：', data_path)
    return data_path

def save_file(file_name, data):
    with open(file_name, 'w') as file:
        file.write(json.dumps(data, indent=4, ensure_ascii=False))
    return

def predict_program(md5_hash, x_logcat_npy_path):
    app_dir = os.path.join(
        settings.UPLD_DIR, md5_hash + '/')  # APP DIRECTORY
    malware_classify_result = os.path.join(app_dir, 'new_malware_classify_result.json')
    
    weight_path = 'MalwareClassify\\weights.46-0.18.hdf5'
    
    result = model_predict(weight_path, x_logcat_npy_path)
    save_file(malware_classify_result, {'is_malware': result})
    return result

def is_malware_auto_dynamic(md5_hash, package, launcher):
    auto_dynamic(md5_hash, package, launcher)
    x_logcat_npy_path = data_convert(md5_hash, package, launcher)
    
    if predict_program(md5_hash, x_logcat_npy_path) == 1:
        return True
    else:
        return False

