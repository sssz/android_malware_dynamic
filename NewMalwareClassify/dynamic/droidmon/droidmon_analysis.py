import os
import json
from static.tools.api_parser import API_PARSER 
from static.tools.string_parser import STRING_PARSER
from static.tools.pscout_parser import PSCOUT_PARSER

LOGTAG_WORKFLOW = "Droidmon-apimonitor-"
LOGTAG_CONCAT = ":{"
PACKAGE_START = len(LOGTAG_WORKFLOW)


class droidmonApi:
    def __init__(self, line):
        self.parse_line(line)

    def is_api(self):
        return self.isApi

    def get_package(self):
        return self.package

    def parse_line(self, line):
        line = line.strip()
        if not line.startswith(LOGTAG_WORKFLOW):
            self.isApi = False
        else:
            package_end = line.find(LOGTAG_CONCAT, PACKAGE_START)
            self.package = line[PACKAGE_START: package_end]
            hook_data_str = line[package_end + 1 : ]
            try:
                self.hook_data = json.loads(hook_data_str)
                self.parse_API()
                if 'type' in self.hook_data:
                    self.isApi = True
            except Exception as e:
                self.isApi = False

    def parse_API(self):
        #permission + intent_action + command + content urls + api
        self.arg_strings = []
        self.extract_string_from_args(self.hook_data.get('args', []), self.arg_strings)
        self.args_info = STRING_PARSER.parse_strings(self.arg_strings)
        self.api = API_PARSER.parse_apis(self.to_parse_format())
        self.pscout = PSCOUT_PARSER.parse_apis(self.to_parse_format())
        
    def extract_string_from_args(self, args, result):
        if args is None:
            return
        if type(args) == list:
            for item in args:
                self.extract_string_from_args(item, result)
        elif type(args) == dict:
            for k in args:
                self.extract_string_from_args(k, result)
                self.extract_string_from_args(args[k], result)
        else:
            result.append(str(args))


    def to_sample_format(self):
        self.sample_api = {
            'type': self.hook_data.get('type', ""),
            'class': self.hook_data.get('class', ""),
            'method': self.hook_data.get('method', ""),
            'timestamp': self.hook_data.get('timestamp', '')
        }
        return self.sample_api
    
    def to_parse_format(self):
        api_sign = self.hook_data.get('class', "") + "->" + self.hook_data.get('method', "")
        api_for_parse = {
            api_sign: {
                'class_name': self.hook_data.get('class', ""),
                'method': self.hook_data.get('method', "")
            }
        }
        return api_for_parse

    def to_save_format(self):
        return {
            #'ts': self.hook_data.get('timestamp', ''),
            #'pkg': self.package,
            #'api': self.api,
            'api_info': self.args_info,
            #'pscout': self.pscout
        }

def get_droidmon_apis(file_path, package):
    apis = []
    with open(file_path, 'r', encoding='utf-8') as droidmon_log:
        for line in droidmon_log:
            api = droidmonApi(line)
            if not api.is_api() or api.get_package() != package:
                continue
            apis.append(api)
    return apis

def droidmon_analysis(file_path, package):
    out_file = os.path.join(os.path.dirname(file_path), "droidmon_out.txt")
    with open(file_path, 'r', encoding='utf-8') as droidmon_log, open(out_file, 'w') as droidmon_out:
        for line in droidmon_log:
            api = droidmonApi(line)
            if not api.is_api() or api.get_package() != package:
                continue
            droidmon_out.write(json.dumps(api.to_sample_format()) + '\n')


global type_2_num
type_2_num = None
def get_api_type_num(api_type):
    global type_2_num
    if type_2_num is None:
        type_2_num = {}
    if not api_type in type_2_num:
        type_2_num[api_type] = len(type_2_num)
    return type_2_num[api_type]


def genone_droidmon_train_data(file_path, out_file):
    last_num = -1
    type_len = 0
    with open(file_path, 'r', encoding='utf-8') as droidmon_log, open(out_file, 'w') as droidmon_train:
        for line in droidmon_log:
            line = line.strip()
            api = json.loads(line)
            cur_num = get_api_type_num(api['type'])
            if cur_num != last_num:
                droidmon_train.write(str(cur_num)+"\n")
                last_num = cur_num
                type_len = type_len + 1
    return type_len

def gen_droidm_train(root, is_malware):
    cnt = 0
    api_lens = []
    for item in os.listdir(root):
        abs_path = os.path.join(root, item)
        if os.path.isdir(abs_path) and abs_path.endswith("_info"):
            droidmon_out = os.path.join(abs_path, "droidmon_out.txt")
            if os.path.exists(droidmon_out):
                droidmon_train = os.path.join(abs_path, "droidmon_train.txt")
                api_lens.append(genone_droidmon_train_data(droidmon_out, droidmon_train))
                cnt = cnt + 1
    with open(("maware" if is_malware else "benign") + '_api_lens.txt', 'w') as f:
        json.dump(api_lens, f)
    with open(os.path.join(root, "apilen.txt"), 'w') as f:
        json.dump(api_lens, f)

    print(cnt)
if __name__ == '__main__':
    #droidmon_analysis("./x_logcat.txt", "com.perfectlove")
    benign_root = input("benign:")
    malware_root = input("malware:")
    #M:\Android_Samples\android_malware\Android_benign\360shoujizhushou\2017-12-03--2017-12-05
    gen_droidm_train(benign_root, 0)
    #M:\Android_Samples\android_malware\Android_malware\drebin-data\drebin-0
    gen_droidm_train(malware_root, 1)
    print(type_2_num)
    '''
    2869 >30 2538
    968 >30 739  
    {'reflection': 0, 'file': 1, 'system': 2, 'sql': 3, 'binder': 4, 'resource': 5, 'crypto': 6, 'globals': 7, 'network': 8, 'dex': 9, 'sms': 10, 'content': 11, 'runtime': 12}
    '''
