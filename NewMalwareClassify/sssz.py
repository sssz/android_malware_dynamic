import os
import time

from static_main import static_analysis_one
from dynamic_main import dynamic_analysis_one
from dynamic.dynamic_run import (dynamic_run, yield_dynamic_run, set_run_state)
from utils import save_json, yield_app_paths
from model.data_loader import (vectorization_one, vectorization_one_flow)
from model.fm import predict_malware

def static(apk_path):
    result_file = os.path.join(apk_path+"_info", "static.json")
    if not os.path.isfile(result_file):
        static_result = {}
        time_cost = static_analysis_one(apk_path, static_result)
        save_json(static_result, result_file)
    else:
        time_cost = 0
    print("static finish. time cost: ", time_cost)

def dynamic(apk_path):
    try:
        if not os.path.isfile(os.path.join(apk_path+"_info", "x_logcat.txt")):
            print("run dynamic test")
            run_time = dynamic_run(apk_path)
        else:
            run_time = 0
            print("has already run dynamic test")
        result_file = os.path.join(apk_path+"_info", "dynamic.json")
        if not os.path.isfile(result_file):
            dynamic_result = {}
            analysis_time = dynamic_analysis_one(apk_path, dynamic_result)
            save_json(dynamic_result, result_file)
        else:
            analysis_time = 0
        print("dynamic finish. time cost: ", run_time + analysis_time)
    except Exception as e:
        time_cost = -1
        print("dynamic", e) #TODO 自动化测试，生成x_logcat.txt


def gen_feature(apk_path):
    static(apk_path)
    dynamic(apk_path)  

def predict(apk_path):
    x_static, x_dynamic, x_hybrid = vectorization_one(apk_path)
    import numpy as np
    return predict_malware(x_static, x_dynamic, x_hybrid)

def predict_flow(apk_path, score):
    for idx, x_static, x_dynamic, x_hybrid in vectorization_one_flow(apk_path):
        cur_score, detail = predict_malware(x_static, x_dynamic, x_hybrid)
        score.append(cur_score)
        if cur_score >= 0.5 and detail[1] > 0.25:
            return 1 + idx
    return 0

def flow_main1():
    root = r"M:\Android_Samples\android_malware\Android_malware\drebin-data\drebin-0"
    seconds = []
    for apk_path in yield_app_paths(root, print_path = False):
        try:
            score = []
            apk_path = os.path.join(root, apk_path)
            seconds.append(predict_flow(apk_path, score))
        except Exception:
            pass
    print("seconds: ", seconds, "avg seconds: ", sum(seconds)/len(seconds))    

def flow_main2():
    apk_path = r"M:\android_malware_dynamic\NewMalwareClassify\sample_malware.apk"
    start_time = time.time()
    static(apk_path)
    malware_time = 0
    for cnt in yield_dynamic_run(apk_path):
        print("dynamic flow idx: ", cnt)
        score = []
        seconds = predict_flow(apk_path, score)
        if(seconds == 0):
            print("\t No malware action found")
        else:
            set_run_state(False)
            malware_time = seconds
            print("\t malware action found, action time: ", seconds)
            break
    if malware_time == 0:
        print("Not Malware.")
    else:
        print("Is malware. Malware action time: ", malware_time, " after run app")
    print("Analysis time cost: ", int(time.time() - start_time), " seconds")

def main():

    apk_path = r"M:\android_malware_dynamic\NewMalwareClassify\sample_benign.apk"
    #apk_path = r"M:\android_malware_dynamic\NewMalwareClassify\sample_malware.apk"
    #apk_path = r"M:\Android_Samples\android_malware\Android_malware\drebin-data\drebin-0\5eccb2a0aea9111a66379998ed23bf2f6fa7a911f7a9049c2a0757dfdb22503e"
    #apk_path = r"M:\Android_Samples\android_malware\Android_benign\360shoujizhushou\2017-12-03--2017-12-05\2e5265fa5e91641f624a4d7818be1f7d8aae09c5.apk"

    gen_feature(apk_path)
    score =  predict(apk_path)
    return score

"""
TODO:
    [Done]1, 基于目前的检测方法，构造实时监测
        输入：apk 的路径
        中间状态：[x1, x2, x3, ...] xi = (x_static, x_dynamic, x_hybrid)
        输出：[r1, r2, ...] ri = (timestamp, result)
        #平均检测时间： 6.04s. 
        #在静态检测的基础上, 平均只需要再让app多运行6s, 即可实现高准确率，高召回的恶意样本检测,大部分只需要运行1s

    [Done]2, 将生成动态api日志的功能移动到此文件夹中
        如果没有xlogcat.txt, 动态运行

    3, 增加模型更新update能力
        输入：old_model, X: 新上传的app, Y: 用户手动指定或virustotal 结果
        输出：模型dump文件
"""

if __name__ == '__main__':
    #result = main()
    #print(result)
    #flow_main1()
    #flow_main2()