import os


from static_main import static_analysis_one
from dynamic_main import dynamic_analysis_one
from utils import save_json, yield_app_paths
from model.data_loader import (vectorization_one, vectorization_one_flow)
from model.fm import predict_malware

def static(apk_path):
    static_result = {}
    time_cost = static_analysis_one(apk_path, static_result)
    result_file = os.path.join(apk_path+"_info", "static.json")
    save_json(static_result, result_file)
    print("static finish. time cost: ", time_cost)

def dynamic(apk_path):
    dynamic_result = {}
    try:
        time_cost = dynamic_analysis_one(apk_path, dynamic_result)
    except Exception as e:
        time_cost = -1
        print("dynamic", e) #TODO 自动化测试，生成x_logcat.txt
    result_file = os.path.join(apk_path+"_info", "dynamic.json")
    save_json(dynamic_result, result_file)
    print("dynamic finish. time cost: ", time_cost)


def main():

    apk_path = r"M:\android_malware_dynamic\NewMalwareClassify\sample_benign.apk"
    apk_path = r"M:\android_malware_dynamic\NewMalwareClassify\sample_malware.apk"
    apk_path = r"M:\Android_Samples\android_malware\Android_malware\drebin-data\drebin-0\5eccb2a0aea9111a66379998ed23bf2f6fa7a911f7a9049c2a0757dfdb22503e"
    apk_path = r"M:\Android_Samples\android_malware\Android_benign\360shoujizhushou\2017-12-03--2017-12-05\2e5265fa5e91641f624a4d7818be1f7d8aae09c5.apk"
    def gen_feature(apk_path):
        static(apk_path)
        dynamic(apk_path)  

    def predict(apk_path):
        x_static, x_dynamic, x_hybrid = vectorization_one(apk_path)
        import numpy as np
        return predict_malware(x_static, x_dynamic, x_hybrid)

    def predict_flow(apk_path, score):
        for idx, x_static, x_dynamic, x_hybrid in vectorization_one_flow(apk_path):
            cur_score = predict_malware(x_static, x_dynamic, x_hybrid)
            score.append(cur_score)
            if cur_score >= 0.5:
                return 1 + idx
        return 0

    #gen_feature(apk_path)

    root = r"M:\Android_Samples\android_malware\Android_malware\drebin-data\drebin-0"
    seconds = []
    for apk_path in yield_app_paths(root, print_path = False):
        try:
            score = []
            apk_path = os.path.join(root, apk_path)
            seconds.append(predict_flow(apk_path, score))
        except Exception:
            pass
    print("seconds: ", seconds, "avg seconds: ", sum(seconds)/len(seconds))
    #score =  predict(apk_path)
    #return score

"""
TODO:
    1, 基于目前的检测方法，构造实时监测
        输入：apk 的路径
        中间状态：[x1, x2, x3, ...] xi = (x_static, x_dynamic, x_hybrid)
        输出：[r1, r2, ...] ri = (timestamp, result)
        #平均检测时间： 1s. 
        #在静态检测的基础上, 平均只需要再让app多运行1s, 即可实现高准确率，高召回的恶意样本检测

    2, 将生成动态api日志的功能移动到此文件夹中
        如果没有xlogcat.txt, 动态运行

    3, 增加模型更新update能力
        输入：old_model, X: 新上传的app, Y: 用户手动指定或virustotal 结果
        输出：模型dump文件
"""

if __name__ == '__main__':
    main()