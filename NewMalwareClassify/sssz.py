import os
import time
import argparse
import sys
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from static_main import static_analysis_one
from dynamic_main import dynamic_analysis_one
from dynamic.dynamic_run import (dynamic_run, yield_dynamic_run, set_run_state)
from utils import save_json, yield_app_paths
from model.data_loader import (vectorization_one, vectorization_one_flow, vectorization_hybrid_cmd)
from model.fm import (predict_malware, train)
from tools.virustotal_analyser import analyse_one as vs_get

def static(apk_path):
    print("【Extract static feature】 start:", apk_path)
    result_file = os.path.join(apk_path+"_info", "static.json")
    if not os.path.isfile(result_file):
        static_result = {}
        time_cost = static_analysis_one(apk_path, static_result)
        save_json(static_result, result_file)
    else:
        time_cost = 0
    print(">>>>>>static finish. time cost: ", time_cost)
    return time_cost

def dynamic(apk_path):
    try:
        print("【Extract dynamic feature】 start:", apk_path)
        if not os.path.isfile(os.path.join(apk_path+"_info", "x_logcat.txt")):
            run_time = dynamic_run(apk_path)
        else:
            run_time = 0
        result_file = os.path.join(apk_path+"_info", "dynamic.json")
        if not os.path.isfile(result_file):
            dynamic_result = {}
            analysis_time = dynamic_analysis_one(apk_path, dynamic_result)
            save_json(dynamic_result, result_file)
        else:
            analysis_time = 0
        time_cost = run_time + analysis_time
        print(">>>>>>dynamic finish. time cost: ", time_cost)
    except Exception as e:
        time_cost = 0
        print("Exception: dynamic", e, apk_path) #TODO 自动化测试，生成x_logcat.txt
    return time_cost

def gen_feature(apk_path):
    tc = 0
    tc += static(apk_path)
    tc += dynamic(apk_path)  
    return tc

def gen_virustotal_label(apk, apk_path):
    print("【Get Virustotal label】 start:", apk_path)
    st = time.time()

    vs_output_path = apk_path + "_info"
    if not os.path.isfile(os.path.join(vs_output_path, apk+".json")):
        vs_get(apk, apk_path, vs_output_path, None, True)
    else:
        "Virustotal label exists"
    tc = int(time.time() - st)
    print(">>>>>>label finish. time cost: ", tc)
    return tc

def predict(apk_path):
    x_static, x_dynamic, x_hybrid = vectorization_one(apk_path)
    import numpy as np
    return predict_malware(x_static, x_dynamic, x_hybrid)

def predict_flow(apk_path, score):
    for idx, x_static, x_dynamic, x_hybrid in vectorization_one_flow(apk_path):
        cur_score, detail = predict_malware(x_static, x_dynamic, x_hybrid)
        score.append(float(cur_score))
        if cur_score >= 0.5 and detail[1] > 0.25:
            return 1 + idx
    return 0

def flow_main1():
    root = r"M:\Android_Samples\android_malware\Android_malware\drebin-data\drebin-0"
    seconds = []
    for apk_path in yield_app_paths(root, print_path = False):
        try:
            score = []
            apk_path = os.path.join(root, apk_path)
            seconds.append(predict_flow(apk_path, score))
        except Exception:
            pass
    print("seconds: ", seconds, "avg seconds: ", sum(seconds)/len(seconds))    

def flow_main2(apk_path):
    #apk_path = r"M:\android_malware_dynamic\NewMalwareClassify\sample_malware.apk"
    start_time = time.time()
    static(apk_path)
    malware_time = 0
    score = []
    for cnt in yield_dynamic_run(apk_path):
        print("dynamic flow idx: ", cnt)
        score = []
        seconds = predict_flow(apk_path, score)
        if(seconds == 0):
            print("\t No malware action found")
        else:
            set_run_state(False)
            malware_time = seconds
            print("\t malware action found, action time: ", seconds)
            break
    if malware_time == 0:
        print("Not Malware.")
    else:
        print("Is malware. Malware action time: ", malware_time, " after run app")
    time_cost = int(time.time() - start_time)
    print("Analysis time cost: ", time_cost)
    return malware_time, score, time_cost

def main(apk_path):

    #apk_path = r"M:\android_malware_dynamic\NewMalwareClassify\sample_benign.apk"
    #apk_path = r"M:\android_malware_dynamic\NewMalwareClassify\sample_malware.apk"
    #apk_path = r"M:\Android_Samples\android_malware\Android_malware\drebin-data\drebin-0\5eccb2a0aea9111a66379998ed23bf2f6fa7a911f7a9049c2a0757dfdb22503e"
    #apk_path = r"M:\Android_Samples\android_malware\Android_benign\360shoujizhushou\2017-12-03--2017-12-05\2e5265fa5e91641f624a4d7818be1f7d8aae09c5.apk"
    start_time = time.time()
    gen_feature(apk_path)
    score, detail =  predict(apk_path)
    print("Apk path: ", apk_path, "Result: ", ("is malware" if score >= 0.5 else "not malware"))
    time_cost = int(time.time() - start_time)
    print("Time cost: ", time_cost)
    return float(score), time_cost

def mas_main(root):
    result = {}
    for apk_path in yield_app_paths(root, print_path = False):
        try:
            apk_path = os.path.join(root, apk_path)
            pred_score, tc = main(apk_path)
            result[apk_path] = {
                "predict": "malware" if pred_score >= 0.5 else "benign",
                "score": pred_score,
                "time_cost": tc
            }
        except Exception:
            pass
    print(result)
    save_json(result, os.path.join(root, "result.json"))

def mas_flow_main(root):
    result = {}
    for apk_path in yield_app_paths(root, print_path = False):
        try:
            apk_path = os.path.join(root, apk_path)
            malware_time, score, time_cost = flow_main2(apk_path)
            result[apk_path] = {
                "predict": "malware" if malware_time > 0 else "benign",
                "malware_time": malware_time,
                "score": score,
                "time_cost": time_cost
            }
        except Exception:
            pass
    print(result)
    save_json(result, os.path.join(root, "result.json"))

def predict_main(args):
    if not os.path.exists(args.path):
        print("Error. Path not exist", args.path)
        return
    if os.path.isfile(args.path):
        if args.mode == "offline":
            main(args.path)
        else:
            flow_main2(args.path)
    elif os.path.isdir(args.path):
        if args.mode == 'offline':
            mas_main(args.path)
        else:
            mas_flow_main(args.path)

def train_main(args):
    if not os.path.isdir(args.benign_path):
        print("Error, benign_path not exist", args.benign_path)
        return
    if not os.path.isdir(args.malware_path):
        print("Error, malware_path not exist", args.malware_path)
        return

    def gen_infos(root):
        for app in yield_app_paths(root, print_path = False):
            apk_path = os.path.join(root, app)
            gen_feature(apk_path)
            gen_virustotal_label(app, apk_path)

    def train_model(malware_path, benign_path):
        X_train, X_test, y_train, y_test= vectorization_hybrid_cmd(malware_path, benign_path)
        print(train(X_train, X_test, y_train, y_test))

    gen_infos(args.benign_path)
    gen_infos(args.malware_path)

    train_model(args.malware_path, args.benign_path)

if __name__ == '__main__':
    #parser = argparse.ArgumentParser()
    #parser.add_argument("-m", "--mode", required=True, type=str, choices=["classify", "classify_flow", "mas_classify", "mas_classify_flow"], )
    #parser.add_argument("-p", "--path", required=True, type=str, help = "if mode is classify or classify_flow, path is file's abs_path; otherwise path is dirname of apks")
    #args = parser.parse_args()
    parser = argparse.ArgumentParser()
    
    subparsers = parser.add_subparsers(dest='subparser_name', help="sub-command help")
    parser_p = subparsers.add_parser('predict', help='predict help')
    parser_p.add_argument("-m", "--mode", required=True, type=str, choices=["offline", "realtime"], help = "realtime model save more time than offline model")
    parser_p.add_argument("-p", "--path", required=True, type=str, help = "file path of apk or directory of apks to predict")
    parser_p.set_defaults(func=predict_main)

    parser_t = subparsers.add_parser('train', help='train help')
    parser_t.add_argument("-bp", "--benign_path", required=True, type=str, help = "directory path of benign apks to train model")
    parser_t.add_argument("-mp", "--malware_path", required=True, type=str, help = "directory path of malware apks to train model")

    parser_t.set_defaults(func=train_main)    
    args = parser.parse_args()
    args.func(args)
