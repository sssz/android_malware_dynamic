import os
import json
from random import shuffle
import traceback
import sys
import copy

import numpy as np

DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(DIR)
from tools.api_parser import API_PARSER 
from tools.string_parser import STRING_PARSER
from utils import (yield_app_paths, yield_app_paths2, sha256, load_json)
from dynamic_main import dynamic_analysis_one_flow

derbin0_feature_root = r"M:\Android_Samples\android_malware\Android_malware\drebin-data\drebin-0"
derbin0_label_root = r"M:\Android_Samples\android_malware\virus_total\derbin_0"
andmal2017_feature_root = r"M:\Android_Samples\android_malware\Android_malware\andmal2017"
andmal2017_label_root = r"M:\Android_Samples\android_malware\virus_total\andmal2017"
benign_360feature_root = r"M:\Android_Samples\android_malware\Android_benign\360shoujizhushou\2017-12-03--2017-12-05"
benign_360label_root = r"M:\Android_Samples\android_malware\virus_total\20191225_360benign"

drebin_feature_root = r"M:\Android_Samples\android_malware\Android_malware\drebin-data\drebin"
drebin_label_root = r"M:\Android_Samples\android_malware\virus_total\drebin"
benign_feature_root = r"M:\Android_Samples\android_malware\Android_benign\360shoujizhushou\360benign"
benign_label_root = r"M:\Android_Samples\android_malware\virus_total\360benign"

DATA_SET_DERBIN0 = dict()
DATA_SET_DREBIN = dict()
DATA_SET_ANDMAL = dict()
DATA_SET_BENIGN360 = dict()
NEG_NUM = -1


'''
    number of permissions: 158
    number of used_features: 76
    number of commands: 148
    number of intent actions: 131
    number of content urls: 8
    number of file paths: 66
    number of apis: 363

        特征向量化
    1750 {
        365 'manifest' : {
            'permission': {0, 1} * 158
            'used_features': {0, 1} * 76
            'intent_action': {0, 1} * 131
        },
        511 'resource': {
            'urls': ??????
            ？？？'hosts': [] ??????
            'permission': {0, 1} * 158
            'command': {0, 1?} * 148
            'intent_action': {0, 1} * 131
            'content_url': {0, 1} * 8
            'path': {0, 1} * 66?
        },
        874 'dex': {
            363 'apis': {0, 1} * 363
            511 'strings': {
                'urls': ??????
                ？？？'hosts': [] ??????
                'permission': {0, 1} * 158
                'command': {0, 1?} * 148
                'intent_action': {0, 1} * 131
                'content_url': {0, 1} * 8
                'path': {0, 1} * 66?
            }
            'libs': >>>>
        }
    }
    1750 + 2*hostname + libs
    动态可采集的：
        permission 158
        intent_action 131
        command 148
        content urls 8
        API 363
        files ???
        hostname ???
'''

#merge permission + intent_action + command + content urls + api
#808=158+131+148+8+363

THRESHOLD = 0.1

def feature_vectorization_static(raw_data):
    vector = []

    def feature_permission(raw_data):
        features = [0] * len(STRING_PARSER.permission_list['values'])
        try:
            for idx, name in enumerate(STRING_PARSER.permission_list['values']):
                if name in raw_data['manifest']['permissions'] or \
                    name in raw_data['resource']['permission'] or \
                    name in raw_data['dex']['strings'].get('permission', []):
                    features[idx] = 1
        except Exception as e:
            pass
            #traceback.print_exc()
        return features
    def feature_intent_action(raw_data):
        features = [0] * len(STRING_PARSER.intent_action_list['actions'])
        try:
            for idx, name in enumerate(STRING_PARSER.intent_action_list['actions']):
                if name in raw_data['manifest']['intent_action'] or \
                    name in raw_data['resource']['intent_action'] or \
                    name in raw_data['dex']['strings'].get('intent_action', []):
                    features[idx] = 1
        except Exception as e:
            pass
            #traceback.print_exc()
        return features

    def feature_command(raw_data):
        features = [0] * len(STRING_PARSER.command_list)
        try:
            for idx, name in enumerate(STRING_PARSER.command_list):
                if name in raw_data['resource']['command'] or \
                    name in raw_data['dex']['strings'].get('command', []):
                    features[idx] = 1
        except Exception as e:
            pass
            #traceback.print_exc()
        return features

    def feature_content_url(raw_data):
        features = [0] * len(STRING_PARSER.content_url_list)
        try:
            for idx, name in enumerate(STRING_PARSER.content_url_list):
                if name in raw_data['resource']['content_url'] or \
                    name in raw_data['dex']['strings'].get('content_url', []):
                    features[idx] = 1
        except Exception as e:
            pass
            #traceback.print_exc()
        return features

    def feature_api(raw_data):
        features = [0] * len(API_PARSER.api_dict)
        try:
            for idx, (key, api) in enumerate(API_PARSER.api_dict.items()):
                if key in raw_data['dex']['apis']:
                    features[idx] = 1
        except Exception as e:
            pass
            #traceback.print_exc()
        return features

    permissions = feature_permission(raw_data)
    intent_action = feature_intent_action(raw_data)
    command = feature_command(raw_data)
    content_url = feature_content_url(raw_data)
    api = feature_api(raw_data)

    vector.extend(permissions)
    vector.extend(intent_action)
    vector.extend(command)
    vector.extend(content_url)
    vector.extend(api)
    return vector

def feature_vectorization_dynamic(raw_data):
    vector = []

    def feature_permission(raw_data):
        features = [0] * len(STRING_PARSER.permission_list['values'])
        try:
            for idx, name in enumerate(STRING_PARSER.permission_list['values']):
                if name in raw_data['pscout'] or \
                    name in raw_data['args_info']['permission']:
                    features[idx] = 1
        except Exception as e:
            pass
            #traceback.print_exc()
        return features
    def feature_intent_action(raw_data):
        features = [0] * len(STRING_PARSER.intent_action_list['actions'])
        try:
            for idx, name in enumerate(STRING_PARSER.intent_action_list['actions']):
                if name in raw_data['args_info']['intent_action']:
                    features[idx] = 1
        except Exception as e:
            pass
            #traceback.print_exc()
        return features

    def feature_command(raw_data):
        features = [0] * len(STRING_PARSER.command_list)
        try:
            for idx, name in enumerate(STRING_PARSER.command_list):
                if name in raw_data['args_info']['command']:
                    features[idx] = 1
        except Exception as e:
            pass
            #traceback.print_exc()
        return features

    def feature_content_url(raw_data):
        features = [0] * len(STRING_PARSER.content_url_list)
        try:
            for idx, name in enumerate(STRING_PARSER.content_url_list):
                if name in raw_data['args_info']['content_url']:
                    features[idx] = 1
        except Exception as e:
            pass
            #traceback.print_exc()
        return features

    def feature_api(raw_data):
        features = [0] * len(API_PARSER.api_dict)
        try:
            for idx, (key, api) in enumerate(API_PARSER.api_dict.items()):
                if key in raw_data['apis']:
                    features[idx] = 1
        except Exception as e:
            pass
            #traceback.print_exc()
        return features

    permissions = feature_permission(raw_data)
    intent_action = feature_intent_action(raw_data)
    command = feature_command(raw_data)
    content_url = feature_content_url(raw_data)
    api = feature_api(raw_data)

    vector.extend(permissions)
    vector.extend(intent_action)
    vector.extend(command)
    vector.extend(content_url)
    vector.extend(api)
    return vector


def load_data(feature_root, feature_name, label_root):
    data = {}
    #for app in os.listdir(feature_root):
    #    if app.endswith('_info') or app.endswith("_info_") or app.endswith(".txt") or app.endswith(".tar"):
    #        continue
    for app in yield_app_paths(feature_root, print_path = False):
        app_path = os.path.join(feature_root, app)
        feature_path = os.path.join(os.path.join(feature_root, app+"_info"), feature_name)
        label_path = os.path.join(label_root, app+".json")
        
        if not (os.path.isfile(feature_path) and os.path.isfile(label_path) and os.path.isfile(app_path)):
            continue
        feature = load_json(feature_path)
        label = load_json(label_path)
        data[app_path] = {
            'feature': feature,
            'label': label
        }
    print("root:", feature_root, "feature_name:", feature_name, "len:", len(data))
    return data

def load_data2(feature_root, feature_name, label_root):
    data = {}
    for sub_root, app in yield_app_paths2(feature_root, print_path = False):
        app_path = os.path.join(sub_root, app)
        feature_path = os.path.join(os.path.join(sub_root, app+"_info"), feature_name)
        
        sub_path = sub_root[len(feature_root)+1:]
        target_dir = os.path.join(label_root, sub_path)
        label_path = os.path.join(target_dir, app+".json")

        if not (os.path.isfile(feature_path) and os.path.isfile(label_path) and os.path.isfile(app_path)):
            continue
        with open(feature_path, 'r') as f:
            feature = json.load(f)
        with open(label_path, 'r') as f:
            label = json.load(f)
        data[app_path] = {
            'feature': feature,
            'label': label
        }
    return data


def evaluate(data, is_positive=0):
    rates = []
    detail = []
    for k in data:
        rate = data[k]['label']['positives'] / data[k]['label']['total']
        rates.append(data[k]['label']['positives'] / data[k]['label']['total'])
        detail.append((data[k]['label']['positives'], data[k]['label']['total']))
    print(sum(rates)/len(rates))
    print(rates)

def clean_data(data, is_positive=0):
    cdata = []
    for k in data:
        rate = data[k]['label']['positives'] / data[k]['label']['total']
        if is_positive == 1 and rate < THRESHOLD:
            continue
        if is_positive == 0 and rate >= THRESHOLD:
            continue
        cdata.append((k, data[k]['label'], data[k]['feature']))
    print("cdata: ", len(cdata))
    return cdata

def save_data_libfm_format(data, rate = 0.7):
    raw_file = r"M:\Android_Samples\android_malware\model_data\raw"
    vector_file = r"M:\Android_Samples\android_malware\model_data\vector"
    def to_raw_string(item):
        #item: (path, label, feature)
        string = item[0] + "\n" + json.dumps(item[1]) + "\n" + json.dumps(item[2]) + "\n" +json.dumps(feature_vectorization_static(item[2]))
        return string

    def to_vector_string(item):
        label = 1 if (item[1]['positives'] / item[1]['total'] >= THRESHOLD) else 0
        vector_feature = feature_vectorization_static(item[2])
        compress_vector = " ".join([str(idx)+str(":")+str(vector_feature[idx]) for idx in range(len(vector_feature)) if vector_feature[idx] != 0])
        return str(label) + " " + compress_vector
    
    last_train = int(len(data) * rate)
    train_positive = 0
    test_positive = 0
    with open(raw_file + "_train", 'w') as r, open(vector_file + "_train", 'w') as v:
        for item in data[: last_train]:
            r.write(to_raw_string(item) + "\n")
            v.write(to_vector_string(item) + "\n")
            train_positive += (1 if (item[1]['positives'] / item[1]['total'] >= THRESHOLD) else 0)

    with open(raw_file + "_test", 'w') as r, open(vector_file + "_test", 'w') as v:
        for item in data[last_train:]:
            r.write(to_raw_string(item) + "\n")
            v.write(to_vector_string(item) + "\n")
            test_positive += (1 if (item[1]['positives'] / item[1]['total'] >= THRESHOLD) else 0)

    print("[train]positive: ", train_positive, "negative: ", last_train - train_positive)
    print("[test]positive: ", test_positive, "negative: ", len(data) - last_train - test_positive)

def merge_vector(vec1, vec2):
    assert len(vec1) == len(vec2)
    tmp = [0]*len(vec1)
    #tmp = [0]*len(vec1)*2
    for idx in range(len(vec1)):
        tmp[idx] = vec1[idx]
        tmp[idx] |= vec2[idx]
        #tmp[idx+len(vec1)] = vec2[idx]

    return tmp

def to_vector(item, func):
    label = 1 if (item[1]['positives'] / item[1]['total'] >= THRESHOLD) else 0
    #vector_feature = feature_vectorization_static(item[2])
    vector_feature = func(item[2])
    return label, vector_feature

def split_data(data, func, rate = 0.7, nparray = True, test_all = False):
    if test_all:
        rate = 0
    last_train = int(len(data) * rate)
    train_positive = 0
    test_positive = 0
    train_x = []
    train_y = []
    test_x = []
    test_y = []
    for item in data[: last_train]:
        y, x = to_vector(item, func)
        train_x.append(x)
        train_y.append(y)
        train_positive += y

    for item in data[last_train:]:
        y, x = to_vector(item, func)
        test_x.append(x)
        test_y.append(y)
        test_positive += y

    print("[train] total: ", len(train_x), " positive: ", train_positive, "negative: ", last_train - train_positive)
    print("[test] total: ", len(test_x), " positive: ", test_positive, "negative: ", len(data) - last_train - test_positive)
    if test_all:
        paths = [item[0] for item in data]
        return paths, test_x, test_y
    if nparray:
        return np.array(train_x), np.array(test_x), np.array(train_y), np.array(test_y)
    else:
        return train_x, test_x, train_y, test_y

#split by malware family
#for andmal2017
def split_data2(data, func, rate = 0.7, is_positive = 0, feature_root = "", nparray = True):
    all_keys = {}
    for sub_root, app in yield_app_paths2(feature_root, print_path = False):
        sub_path = sub_root[len(feature_root)+1:]
        all_keys[sub_path] = 1
    all_keys = list(all_keys.keys())
    shuffle(all_keys)
    last_train_key = int(rate*len(all_keys))
    train_keys = all_keys[:last_train_key]
    test_keys = all_keys[last_train_key:]
    train_positive = train_negative = test_positive = test_negative = 0
    train_x = []
    train_y = []
    test_x = []
    test_y = []
    for item in data:
        label, v = to_vector(item, func)
        if label == 0:
            if train_negative < len(data)*rate:
                train_x.append(v)
                train_y.append(label)
                train_negative += 1
            else:
                test_x.append(v)
                test_y.append(label)
                test_negative += 1
        else:
            is_test = False
            for k in test_keys:
                if k in item[0]:
                    is_test = True
                    break
            if is_test:
                test_x.append(v)
                test_y.append(label)
                test_positive += 1
            else:
                train_x.append(v)
                train_y.append(label)
                train_positive += 1

    print("[train] total: ", len(train_x), " positive: ", train_positive, "negative: ", train_negative)
    print("[test] total: ", len(test_x), " positive: ", test_positive, "negative: ", test_negative)

    if nparray:
        return np.array(train_x), np.array(test_x), np.array(train_y), np.array(test_y)
    else:
        return train_x, test_x, train_y, test_y
    
def vectorization_main(data_name = "derbin_0", feature_name = "static.json", nparray = True, test_all = False):
    
    if data_name == 'derbin_0':
        global DATA_SET_DERBIN0
        if feature_name not in DATA_SET_DERBIN0:
            derbin_0 = load_data(derbin0_feature_root, feature_name, derbin0_label_root)
            derbin_0 = clean_data(derbin_0, is_positive = 1)
            DATA_SET_DERBIN0[feature_name] = copy.deepcopy(derbin_0)
        malware = copy.deepcopy(DATA_SET_DERBIN0[feature_name])
    if data_name == 'drebin':
        global DATA_SET_DREBIN
        if feature_name not in DATA_SET_DREBIN:
            drebin = load_data(drebin_feature_root, feature_name, drebin_label_root)
            drebin = clean_data(drebin, is_positive = 1)
            DATA_SET_DREBIN[feature_name] = copy.deepcopy(drebin)
        malware = copy.deepcopy(DATA_SET_DREBIN[feature_name])
    if data_name =='andmal2017':
        global DATA_SET_ANDMAL
        if feature_name not in DATA_SET_ANDMAL:
            andmal2017 = load_data2(andmal2017_feature_root, feature_name, andmal2017_label_root)
            andmal2017 = clean_data(andmal2017, is_positive = 1)
            DATA_SET_ANDMAL[feature_name] = copy.deepcopy(andmal2017)
        malware = copy.deepcopy(DATA_SET_ANDMAL[feature_name])

    global DATA_SET_BENIGN360
    if feature_name not in DATA_SET_BENIGN360:
        #benign_360 = load_data(benign_360feature_root, feature_name, benign_360label_root)
        #benign_360 = clean_data(benign_360)
        benign_360 = load_data(benign_feature_root, feature_name, benign_label_root)
        benign_360 = clean_data(benign_360)
        DATA_SET_BENIGN360[feature_name] = copy.deepcopy(benign_360)
    benign_360 = copy.deepcopy(DATA_SET_BENIGN360[feature_name])
    
    
    data_set = malware + benign_360
    print("[data_set] positive: ", len(malware), "negative: ", len(benign_360))
    shuffle(data_set)

    func = (feature_vectorization_static if feature_name == 'static.json' else  feature_vectorization_dynamic)
    return split_data(data_set, func, nparray=nparray, test_all=test_all)


def vectorization_hybrid(data_name = "derbin_0", nparray = True, test_all = False):
    malware = {}
    benign = {}
    for feature_name in ['static.json', 'dynamic.json']:
        if data_name == 'derbin_0':
            global DATA_SET_DERBIN0
            if feature_name not in DATA_SET_DERBIN0:
                derbin_0 = load_data(derbin0_feature_root, feature_name, derbin0_label_root)
                derbin_0 = clean_data(derbin_0, is_positive = 1)
                DATA_SET_DERBIN0[feature_name] = copy.deepcopy(derbin_0)
            for item in DATA_SET_DERBIN0[feature_name]:
                malware.setdefault(item[0], {}).setdefault(feature_name, item)
        if data_name == 'drebin':
            global DATA_SET_DREBIN
            if feature_name not in DATA_SET_DREBIN:
                drebin = load_data(drebin_feature_root, feature_name, drebin_label_root)
                drebin = clean_data(drebin, is_positive = 1)
                DATA_SET_DREBIN[feature_name] = copy.deepcopy(drebin)
            for item in DATA_SET_DREBIN[feature_name]:
                malware.setdefault(item[0], {}).setdefault(feature_name, item)
        if data_name =='andmal2017':
            global DATA_SET_ANDMAL
            if feature_name not in DATA_SET_ANDMAL:
                andmal2017 = load_data2(andmal2017_feature_root, feature_name, andmal2017_label_root)
                andmal2017 = clean_data(andmal2017, is_positive = 1)
                DATA_SET_ANDMAL[feature_name] = copy.deepcopy(andmal2017)
            for item in DATA_SET_ANDMAL[feature_name]:
                malware.setdefault(item[0], {}).setdefault(feature_name, item)
        global DATA_SET_BENIGN360
        if feature_name not in DATA_SET_BENIGN360:
            benign_360 = load_data(benign_feature_root, feature_name, benign_label_root)
            benign_360 = clean_data(benign_360)
            DATA_SET_BENIGN360[feature_name] = copy.deepcopy(benign_360)
        for item in DATA_SET_BENIGN360[feature_name]:
                benign.setdefault(item[0], {}).setdefault(feature_name, item)

    print("[data_set] positive: ", len(malware), "negative: ", len(benign))
    malware.update(benign)
    data_set = []
    for k in malware:
        static_feature = {}
        dynamic_feature = {}
        if 'static.json' in malware[k]:
            apk_path = malware[k]['static.json'][0]
            label = malware[k]['static.json'][1]
            static_feature = malware[k]['static.json'][2]
        if 'dynamic.json' in malware[k]:
            apk_path = malware[k]['dynamic.json'][0]
            label = malware[k]['dynamic.json'][1]
            dynamic_feature = malware[k]['dynamic.json'][2]
        data_set.append((apk_path, label, (static_feature, dynamic_feature)))


    def vector_mix(feature):
        static_vec = feature_vectorization_static(feature[0])
        dynamic_vec = feature_vectorization_dynamic(feature[1])
        hybrid_vec = merge_vector(static_vec, dynamic_vec)
        return hybrid_vec

    shuffle(data_set)
    return split_data(data_set, vector_mix, nparray=nparray, test_all=test_all)


def vectorization_one(apk_path):
    static_feature_path = os.path.join(apk_path+"_info", "static.json")
    dynamic_feature_path = os.path.join(apk_path+"_info", "dynamic.json")

    static_feature = load_json(static_feature_path)
    dynamic_feature = load_json(dynamic_feature_path)

    static_vec = feature_vectorization_static(static_feature)
    dynamic_vec = feature_vectorization_dynamic(dynamic_feature)
    hybrid_vec = merge_vector(static_vec, dynamic_vec)

    return static_vec, dynamic_vec, hybrid_vec

def vectorization_one_flow(apk_path):
    static_feature_path = os.path.join(apk_path+"_info", "static.json")
    static_feature = load_json(static_feature_path)
    static_vec = feature_vectorization_static(static_feature)

    _, dynamic_flow = dynamic_analysis_one_flow(apk_path)

    for idx in range(len(dynamic_flow)):
        dynamic_feature = dynamic_flow[idx]
        dynamic_vec = feature_vectorization_dynamic(dynamic_feature)
        hybrid_vec = merge_vector(static_vec, dynamic_vec)
        yield idx, static_vec, dynamic_vec, hybrid_vec

def vectorization_andmal2017(nparray = True):
    andmal2017_feature_root = r"M:\Android_Samples\android_malware\Android_malware\andmal2017"
    andmal2017_label_root = r"M:\Android_Samples\android_malware\virus_total\andmal2017"
    benign_360feature_root = r"M:\Android_Samples\android_malware\Android_benign\360shoujizhushou\2017-12-03--2017-12-05"
    benign_360label_root = r"M:\Android_Samples\android_malware\virus_total\20191225_360benign"

    global DATA_SET_ANDMAL
    global DATA_SET_BENIGN360
    if DATA_SET_ANDMAL is None:
        andmal2017 = load_data2(andmal2017_feature_root, andmal2017_label_root)
        DATA_SET_ANDMAL = copy.deepcopy(andmal2017)
    andmal2017 = copy.deepcopy(DATA_SET_ANDMAL)

    if DATA_SET_BENIGN360 is None:
        benign_360 = load_data(benign_360feature_root, benign_360label_root)
        DATA_SET_BENIGN360 = copy.deepcopy(benign_360)
    benign_360 = copy.deepcopy(DATA_SET_BENIGN360)

    andmal2017 = clean_data(andmal2017, is_positive = 1)
    benign_360 = clean_data(benign_360)
    print("[data_set]positive: ", len(andmal2017), "negative: ", len(benign_360))
    data_set = andmal2017 + benign_360
    
    shuffle(data_set)

    return split_data2(data_set, feature_root=andmal2017_feature_root, nparray=nparray)
    #return split_data(data_set)

def get_sha():
    derbin0_feature_root = r"M:\Android_Samples\android_malware\Android_malware\drebin-data\drebin-0"
    andmal2017_feature_root = r"M:\Android_Samples\android_malware\Android_malware\andmal2017"

    sha_derbin  = {}
    for app in yield_app_paths(derbin0_feature_root, print_path = False):
        app_path = os.path.join(derbin0_feature_root, app)
        sha = sha256(app_path)
        sha_derbin[sha] = 1

    sha_andmal = {}
    for sub_root, app in yield_app_paths2(andmal2017_feature_root, print_path = False):
        app_path = os.path.join(sub_root, app)
        sha = sha256(app_path)
        sha_andmal[sha] = 1
    print(len(sha_derbin))#983
    print(len(sha_andmal))#377

    interact = 0
    for k in sha_andmal:
        if k in sha_derbin:
            interact += 1
    print(interact)#4

def vectorization_mix():
    train_x_derbin, test_x_derbin, train_y_derbin, test_y_derbin = vectorization_main(nparray = False)
    train_x_andmal, test_x_andmal, train_y_andmal, test_y_andmal = vectorization_andmal2017(nparray = False)
    #derbin 训练， andmal测试
    
    train = []
    test = []
    train_positive = 0
    test_positive = 0
    for idx in range(len(train_y_derbin)):
        train.append((train_x_derbin[idx], train_y_derbin[idx]))
        train_positive += train_y_derbin[idx]
    for idx in range(len(test_y_derbin)):
        if test_y_derbin[idx] == 1:
            train.append((test_x_derbin[idx], test_y_derbin[idx]))
            train_positive += 1
        else:
            test.append((test_x_derbin[idx], test_y_derbin[idx]))


    for idx in range(len(train_y_andmal)):
        if train_y_andmal[idx] == 1:
            test.append((train_x_andmal[idx], train_y_andmal[idx]))
            test_positive += 1

    for idx in range(len(test_y_andmal)):
        if test_y_andmal[idx] == 1:
            test.append((test_x_andmal[idx], test_y_andmal[idx]))
            test_positive += 1

    shuffle(train)
    shuffle(test)
    train_x = [item[0] for item in train]
    train_y = [item[1] for item in train]
    test_x = [item[0] for item in test]
    test_y = [item[1] for item in test]

    print("[train] total: ", len(train_x), " positive: ", train_positive, "negative: ", len(train_x) - train_positive)
    print("[test] total: ", len(test_x), " positive: ", test_positive, "negative: ", len(test_x) - test_positive)   
    return np.array(train_x), np.array(test_x), np.array(train_y), np.array(test_y)




if __name__ == '__main__':
    #path = "M:\\Android_Samples\\android_malware\\Android_benign\\360shoujizhushou\\2017-12-03--2017-12-05\\1bba6a0486ae43e92992ce96191a6ae9059935a5.apk_info\\static.json"
    #data = json.load(open(path))
    #print(feature_vectorization_static(data))
    #vectorization_main(feature_name = "dynamic.json")
    #vectorization_andmal2017()
    #get_sha()
    #vectorization_mix()
    #vectorization_hybrid()
    print("drebin")
    data_stats(drebin_feature_root, drebin_label_root)
    print("benign")
    data_stats(benign_feature_root, benign_label_root)
    