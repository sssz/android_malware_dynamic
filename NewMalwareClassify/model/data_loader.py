import os
import json
from random import shuffle
import traceback
import sys
import copy

import numpy as np

DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(DIR)
from static.tools.api_parser import API_PARSER 
from static.tools.string_parser import STRING_PARSER
from utils import (yield_app_paths, yield_app_paths2, sha256)


DATA_SET_DERBIN0 = None
DATA_SET_ANDMAL = None
DATA_SET_BENIGN360 = None
NEG_NUM = -1


'''
    number of permissions: 158
    number of used_features: 76
    number of commands: 148
    number of intent actions: 131
    number of content urls: 8
    number of file paths: 66
    number of apis: 363

        特征向量化
    1750 {
        365 'manifest' : {
            'permission': {0, 1} * 158
            'used_features': {0, 1} * 76
            'intent_action': {0, 1} * 131
        },
        511 'resource': {
            'urls': ??????
            ？？？'hosts': [] ??????
            'permission': {0, 1} * 158
            'command': {0, 1?} * 148
            'intent_action': {0, 1} * 131
            'content_url': {0, 1} * 8
            'path': {0, 1} * 66?
        },
        874 'dex': {
            363 'apis': {0, 1} * 363
            511 'strings': {
                'urls': ??????
                ？？？'hosts': [] ??????
                'permission': {0, 1} * 158
                'command': {0, 1?} * 148
                'intent_action': {0, 1} * 131
                'content_url': {0, 1} * 8
                'path': {0, 1} * 66?
            }
            'libs': >>>>
        }
    }
    1750 + 2*hostname + libs
    动态可采集的：
        permission 158
        intent_action 131
        command 148
        content urls 8
        API 363
        files ???
        hostname ???
'''

#merge permission + intent_action + command + content urls + api
#808=158+131+148+8+363

THRESHOLD = 0.1

def save_json(data, file_name):
    with open(file_name, 'w') as f:
        json.dump(data, f, indent=4)


def feature_vectorization_1(raw_data):
    vector = []

    def feature_permission(raw_data):
        features = [0] * len(STRING_PARSER.permission_list['values'])
        try:
            for idx, name in enumerate(STRING_PARSER.permission_list['values']):
                if name in raw_data['manifest']['permissions'] or \
                    name in raw_data['resource']['permission'] or \
                    name in raw_data['dex']['strings']['permission']:
                    features[idx] = 1
        except Exception as e:
            pass
            #traceback.print_exc()
        return features
    def feature_intent_action(raw_data):
        features = [0] * len(STRING_PARSER.intent_action_list['actions'])
        try:
            for idx, name in enumerate(STRING_PARSER.intent_action_list['actions']):
                if name in raw_data['manifest']['intent_action'] or \
                    name in raw_data['resource']['intent_action'] or \
                    name in raw_data['dex']['strings']['intent_action']:
                    features[idx] = 1
        except Exception as e:
            pass
            #traceback.print_exc()
        return features

    def feature_command(raw_data):
        features = [0] * len(STRING_PARSER.command_list)
        try:
            for idx, name in enumerate(STRING_PARSER.command_list):
                if name in raw_data['resource']['command'] or \
                    name in raw_data['dex']['strings']['command']:
                    features[idx] = 1
        except Exception as e:
            pass
            #traceback.print_exc()
        return features

    def feature_content_url(raw_data):
        features = [0] * len(STRING_PARSER.content_url_list)
        try:
            for idx, name in enumerate(STRING_PARSER.content_url_list):
                if name in raw_data['resource']['content_url'] or \
                    name in raw_data['dex']['strings']['content_url']:
                    features[idx] = 1
        except Exception as e:
            pass
            #traceback.print_exc()
        return features

    def feature_api(raw_data):
        features = [0] * len(API_PARSER.api_dict)
        try:
            for idx, (key, api) in enumerate(API_PARSER.api_dict.items()):
                if key in raw_data['dex']['apis']:
                    features[idx] = 1
        except Exception as e:
            pass
            #traceback.print_exc()
        return features

    permissions = feature_permission(raw_data)
    intent_action = feature_intent_action(raw_data)
    command = feature_command(raw_data)
    content_url = feature_content_url(raw_data)
    api = feature_api(raw_data)

    vector.extend(permissions)
    vector.extend(intent_action)
    vector.extend(command)
    vector.extend(content_url)
    vector.extend(api)
    return vector



def load_data(feature_root, label_root):
    data = {}
    #for app in os.listdir(feature_root):
    #    if app.endswith('_info') or app.endswith("_info_") or app.endswith(".txt") or app.endswith(".tar"):
    #        continue
    for app in yield_app_paths(feature_root, print_path = False):
        app_path = os.path.join(feature_root, app)
        feature_path = os.path.join(os.path.join(feature_root, app+"_info"), "static.json")
        label_path = os.path.join(label_root, app+".json")
        
        if not (os.path.isfile(feature_path) and os.path.isfile(label_path) and os.path.isfile(app_path)):
            continue
        with open(feature_path, 'r') as f:
            feature = json.load(f)
        with open(label_path, 'r') as f:
            label = json.load(f)
        data[app_path] = {
            'feature': feature,
            'label': label
        }
    return data

def load_data2(feature_root, label_root):
    data = {}
    for sub_root, app in yield_app_paths2(feature_root, print_path = False):
        app_path = os.path.join(sub_root, app)
        feature_path = os.path.join(os.path.join(sub_root, app+"_info"), "static.json")
        
        sub_path = sub_root[len(feature_root)+1:]
        target_dir = os.path.join(label_root, sub_path)
        label_path = os.path.join(target_dir, app+".json")

        if not (os.path.isfile(feature_path) and os.path.isfile(label_path) and os.path.isfile(app_path)):
            continue
        with open(feature_path, 'r') as f:
            feature = json.load(f)
        with open(label_path, 'r') as f:
            label = json.load(f)
        data[app_path] = {
            'feature': feature,
            'label': label
        }
    return data


def evaluate(data, is_positive=0):
    rates = []
    detail = []
    for k in data:
        rate = data[k]['label']['positives'] / data[k]['label']['total']
        rates.append(data[k]['label']['positives'] / data[k]['label']['total'])
        detail.append((data[k]['label']['positives'], data[k]['label']['total']))
    print(sum(rates)/len(rates))
    print(rates)

def clean_data(data, is_positive=0):
    cdata = []
    for k in data:
        rate = data[k]['label']['positives'] / data[k]['label']['total']
        if is_positive == 1 and rate < THRESHOLD:
            continue
        if is_positive == 0 and rate >= THRESHOLD:
            continue
        cdata.append((k, data[k]['label'], data[k]['feature']))
    return cdata

def save_data_libfm_format(data, rate = 0.7):
    raw_file = r"M:\Android_Samples\android_malware\model_data\raw"
    vector_file = r"M:\Android_Samples\android_malware\model_data\vector"
    def to_raw_string(item):
        #item: (path, label, feature)
        string = item[0] + "\n" + json.dumps(item[1]) + "\n" + json.dumps(item[2]) + "\n" +json.dumps(feature_vectorization_1(item[2]))
        return string

    def to_vector_string(item):
        label = 1 if (item[1]['positives'] / item[1]['total'] >= THRESHOLD) else 0
        vector_feature = feature_vectorization_1(item[2])
        compress_vector = " ".join([str(idx)+str(":")+str(vector_feature[idx]) for idx in range(len(vector_feature)) if vector_feature[idx] != 0])
        return str(label) + " " + compress_vector
    
    last_train = int(len(data) * rate)
    train_positive = 0
    test_positive = 0
    with open(raw_file + "_train", 'w') as r, open(vector_file + "_train", 'w') as v:
        for item in data[: last_train]:
            r.write(to_raw_string(item) + "\n")
            v.write(to_vector_string(item) + "\n")
            train_positive += (1 if (item[1]['positives'] / item[1]['total'] >= THRESHOLD) else 0)

    with open(raw_file + "_test", 'w') as r, open(vector_file + "_test", 'w') as v:
        for item in data[last_train:]:
            r.write(to_raw_string(item) + "\n")
            v.write(to_vector_string(item) + "\n")
            test_positive += (1 if (item[1]['positives'] / item[1]['total'] >= THRESHOLD) else 0)

    print("[train]positive: ", train_positive, "negative: ", last_train - train_positive)
    print("[test]positive: ", test_positive, "negative: ", len(data) - last_train - test_positive)

def to_vector(item):
    label = 1 if (item[1]['positives'] / item[1]['total'] >= THRESHOLD) else 0
    vector_feature = feature_vectorization_1(item[2])
    return label, vector_feature

def split_data(data, rate = 0.7, nparray = True):    
    last_train = int(len(data) * rate)
    train_positive = 0
    test_positive = 0
    train_x = []
    train_y = []
    test_x = []
    test_y = []
    for item in data[: last_train]:
        y, x = to_vector(item)
        train_x.append(x)
        train_y.append(y)
        train_positive += y

    for item in data[last_train:]:
        y, x = to_vector(item)
        test_x.append(x)
        test_y.append(y)
        test_positive += y

    print("[train] total: ", len(train_x), " positive: ", train_positive, "negative: ", last_train - train_positive)
    print("[test] total: ", len(test_x), " positive: ", test_positive, "negative: ", len(data) - last_train - test_positive)
    if nparray:
        return np.array(train_x), np.array(test_x), np.array(train_y), np.array(test_y)
    else:
        return train_x, test_x, train_y, test_y

def split_data2(data, neg_num = 0, rate = 0.7, is_positive = 0, feature_root = "", nparray = True):
    all_keys = {}
    for sub_root, app in yield_app_paths2(feature_root, print_path = False):
        sub_path = sub_root[len(feature_root)+1:]
        all_keys[sub_path] = 1
    all_keys = list(all_keys.keys())
    shuffle(all_keys)
    last_train_key = int(rate*len(all_keys))
    train_keys = all_keys[:last_train_key]
    test_keys = all_keys[last_train_key:]
    train_positive = train_negative = test_positive = test_negative = 0
    train_x = []
    train_y = []
    test_x = []
    test_y = []
    for item in data:
        label, v = to_vector(item)
        if label == 0:
            if train_negative < len(data)*rate:
                train_x.append(v)
                train_y.append(label)
                train_negative += 1
            else:
                test_x.append(v)
                test_y.append(label)
                test_negative += 1
        else:
            is_test = False
            for k in test_keys:
                if k in item[0]:
                    is_test = True
                    break
            if is_test:
                test_x.append(v)
                test_y.append(label)
                test_positive += 1
            else:
                train_x.append(v)
                train_y.append(label)
                train_positive += 1

    print("[train] total: ", len(train_x), " positive: ", train_positive, "negative: ", train_negative)
    print("[test] total: ", len(test_x), " positive: ", test_positive, "negative: ", test_negative)

    if nparray:
        return np.array(train_x), np.array(test_x), np.array(train_y), np.array(test_y)
    else:
        return train_x, test_x, train_y, test_y
    
def vectorization_main(nparray = True):
    derbin0_feature_root = r"M:\Android_Samples\android_malware\Android_malware\drebin-data\drebin-0"
    derbin0_label_root = r"M:\Android_Samples\android_malware\virus_total\derbin_0"
    benign_360feature_root = r"M:\Android_Samples\android_malware\Android_benign\360shoujizhushou\2017-12-03--2017-12-05"
    benign_360label_root = r"M:\Android_Samples\android_malware\virus_total\20191225_360benign"
    
    global DATA_SET_DERBIN0
    global DATA_SET_BENIGN360
    global NEG_NUM
    if DATA_SET_DERBIN0 is None:
        derbin_0 = load_data(derbin0_feature_root, derbin0_label_root)
        DATA_SET_DERBIN0 = copy.deepcopy(derbin_0)
    derbin_0 = copy.deepcopy(DATA_SET_DERBIN0)

    if DATA_SET_BENIGN360 is None:
        benign_360 = load_data(benign_360feature_root, benign_360label_root)
        DATA_SET_BENIGN360 = copy.deepcopy(benign_360)
    benign_360 = copy.deepcopy(DATA_SET_BENIGN360)


    #print(len(derbin_0))
    #evaluate(derbin_0)

    #print(len(benign_360))
    #evaluate(benign_360)
    derbin_0 = clean_data(derbin_0, is_positive = 1)
    benign_360 = clean_data(benign_360)
    print("[data_set]positive: ", len(derbin_0), "negative: ", len(benign_360))
    data_set = derbin_0 + benign_360
    NEG_NUM = len(benign_360)

    shuffle(data_set)

    return split_data(data_set, nparray=nparray)



def vectorization_andmal2017(nparray = True):
    andmal2017_feature_root = r"M:\Android_Samples\android_malware\Android_malware\andmal2017"
    andmal2017_label_root = r"M:\Android_Samples\android_malware\virus_total\andmal2017"
    benign_360feature_root = r"M:\Android_Samples\android_malware\Android_benign\360shoujizhushou\2017-12-03--2017-12-05"
    benign_360label_root = r"M:\Android_Samples\android_malware\virus_total\20191225_360benign"

    global DATA_SET_ANDMAL
    global DATA_SET_BENIGN360
    global NEG_NUM
    if DATA_SET_ANDMAL is None:
        andmal2017 = load_data2(andmal2017_feature_root, andmal2017_label_root)
        DATA_SET_ANDMAL = copy.deepcopy(andmal2017)
    andmal2017 = copy.deepcopy(DATA_SET_ANDMAL)

    if DATA_SET_BENIGN360 is None:
        benign_360 = load_data(benign_360feature_root, benign_360label_root)
        DATA_SET_BENIGN360 = copy.deepcopy(benign_360)
    benign_360 = copy.deepcopy(DATA_SET_BENIGN360)

    andmal2017 = clean_data(andmal2017, is_positive = 1)
    benign_360 = clean_data(benign_360)
    print("[data_set]positive: ", len(andmal2017), "negative: ", len(benign_360))
    data_set = andmal2017 + benign_360
    NEG_NUM = len(benign_360)
    
    shuffle(data_set)

    return split_data2(data_set, neg_num = NEG_NUM, feature_root=andmal2017_feature_root, nparray=nparray)
    #return split_data(data_set)

def get_sha():
    derbin0_feature_root = r"M:\Android_Samples\android_malware\Android_malware\drebin-data\drebin-0"
    andmal2017_feature_root = r"M:\Android_Samples\android_malware\Android_malware\andmal2017"

    sha_derbin  = {}
    for app in yield_app_paths(derbin0_feature_root, print_path = False):
        app_path = os.path.join(derbin0_feature_root, app)
        sha = sha256(app_path)
        sha_derbin[sha] = 1

    sha_andmal = {}
    for sub_root, app in yield_app_paths2(andmal2017_feature_root, print_path = False):
        app_path = os.path.join(sub_root, app)
        sha = sha256(app_path)
        sha_andmal[sha] = 1
    print(len(sha_derbin))#983
    print(len(sha_andmal))#377

    interact = 0
    for k in sha_andmal:
        if k in sha_derbin:
            interact += 1
    print(interact)#4


def vectorization_mix():
    train_x_derbin, test_x_derbin, train_y_derbin, test_y_derbin = vectorization_main(nparray = False)
    train_x_andmal, test_x_andmal, train_y_andmal, test_y_andmal = vectorization_andmal2017(nparray = False)
    #derbin 训练， andmal测试
    
    train = []
    test = []
    train_positive = 0
    test_positive = 0
    for idx in range(len(train_y_derbin)):
        train.append((train_x_derbin[idx], train_y_derbin[idx]))
        train_positive += train_y_derbin[idx]
    for idx in range(len(test_y_derbin)):
        if test_y_derbin[idx] == 1:
            train.append((test_x_derbin[idx], test_y_derbin[idx]))
            train_positive += 1
        else:
            test.append((test_x_derbin[idx], test_y_derbin[idx]))


    for idx in range(len(train_y_andmal)):
        if train_y_andmal[idx] == 1:
            test.append((train_x_andmal[idx], train_y_andmal[idx]))
            test_positive += 1

    for idx in range(len(test_y_andmal)):
        if test_y_andmal[idx] == 1:
            test.append((test_x_andmal[idx], test_y_andmal[idx]))
            test_positive += 1

    shuffle(train)
    shuffle(test)
    train_x = [item[0] for item in train]
    train_y = [item[1] for item in train]
    test_x = [item[0] for item in test]
    test_y = [item[1] for item in test]

    print("[train] total: ", len(train_x), " positive: ", train_positive, "negative: ", len(train_x) - train_positive)
    print("[test] total: ", len(test_x), " positive: ", test_positive, "negative: ", len(test_x) - test_positive)   
    return np.array(train_x), np.array(test_x), np.array(train_y), np.array(test_y)


if __name__ == '__main__':
    #path = "M:\\Android_Samples\\android_malware\\Android_benign\\360shoujizhushou\\2017-12-03--2017-12-05\\1bba6a0486ae43e92992ce96191a6ae9059935a5.apk_info\\static.json"
    #data = json.load(open(path))
    #print(feature_vectorization_1(data))
    #vectorization_main()
    #vectorization_andmal2017()
    #get_sha()
    vectorization_mix()
