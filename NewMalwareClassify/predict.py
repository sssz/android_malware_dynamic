# -*- coding:UTF-8 -*-
#! C:\Users\davidblus\Anaconda3\python

from keras.models import load_model
import numpy as np
import sys

from MalwareClassify.binary_accuracy_metrics import precision, recall


# 当文件时间步与指定的时间步不同时，采用填充0或者截断的方法使其达到指定的时间步
def pad_or_thunk(filedata, timesteps):
    file_timesteps = filedata.shape[0]
    file_data_dim = filedata.shape[1]
    if file_timesteps >= timesteps:
        return filedata[:timesteps]
    else:
        pad_file_data = np.zeros(shape=(timesteps, file_data_dim))
        pad_file_data[:file_timesteps] = filedata
        return pad_file_data

def load_npy_data(npy_file_path, timesteps, data_dim):
    data = np.zeros(shape=(1, timesteps, data_dim))
    
    filedata = np.load(npy_file_path)
    filedata = pad_or_thunk(filedata, timesteps)
    data[0] = filedata
    return data

def model_predict(weights_file_path, npy_file_path):
    timesteps = 100
    data_dim = 200
    
    model = load_model(weights_file_path, custom_objects={'precision': precision, 'recall': recall})
    
    data = load_npy_data(npy_file_path, timesteps, data_dim)
    predict_y = model.predict(data, batch_size=32)
    predict_y = round(float(predict_y[0]))
    print('predict:%s' % predict_y)
    
    return predict_y

def test():
    # weights_file_path = input('请输入模型权值文件路径：')
    # npy_file_path = input('请输入 npy 特征文件路径：')
    weights_file_path = sys.argv[1]
    npy_file_path = sys.argv[2]
    
    model_predict(weights_file_path, npy_file_path)
    return

if __name__ == '__main__':
    test()
