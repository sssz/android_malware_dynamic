# -*- coding: utf8 -*-

import os
os.environ.update({"DJANGO_SETTINGS_MODULE": "MobSF.settings"})
import shutil
import MobSF.settings as SETTINGS
SETTINGS.AUTO_DYNAMIC = True

from DynamicAnalyzer.views.android.avd import (avd_load_wait, refresh_avd)
from DynamicAnalyzer.views.android.shared import (connect, install_and_run, get_identifier)
from DynamicAnalyzer.views.android.virtualbox_vm import (refresh_vm)
from NewMalwareClassify.strace.strace_generate import (start_strace)
from NewMalwareClassify.strace.strace_analysis import (strace_analysis)
from NewMalwareClassify.droidmon.droidmon_generator import (start_download)
from NewMalwareClassify.droidmon.droidmon_analysis import (droidmon_analysis)

from MobSF.utils import getADB
from StaticAnalyzer.views.android.manifest_analysis import get_manifest
from StaticAnalyzer.views.android.manifest_analysis import manifest_data as get_manifest_data
from StaticAnalyzer.views.shared_func import unzip


import json
import signal
import subprocess
import threading
import time
import traceback
import json
import hashlib
import io

BASE_DIR = '.'
DEBUGING = False
DEBUGING_NUMS = 3
UPLOAD_DIR = os.path.join(BASE_DIR, 'uploads')
ORIGIN_DOWNLOAD_DIR = os.path.join(BASE_DIR, 'downloads')
DYNAMIC_TOOL_DIR = os.path.join(os.path.join(BASE_DIR, 'DynamicAnalyzer'), 'tools')
STATIC_TOOL_DIR = os.path.join(os.path.join(BASE_DIR, 'StaticAnalyzer'), 'tools')


def genMD5(app):
    BLOCKSIZE = 65536
    hasher = hashlib.md5()
    with open(app, 'rb') as afile:
        buf = afile.read(BLOCKSIZE)
        while buf:
            hasher.update(buf)
            buf = afile.read(BLOCKSIZE)
    return (hasher.hexdigest())


def get_static_info(file_path, file_md5):

    unzip_dir = file_path + "_info/" + file_md5 + "/"


    unzip_result = unzip(file_path, unzip_dir)
    print('len(unzip_result):', len(unzip_result))
    
    apk_path = unzip_dir + file_md5 + ".apk"
    shutil.copy(file_path, apk_path)
    
    manifest_xml = get_manifest(apk_path, unzip_dir, STATIC_TOOL_DIR, '', True)
    print('manifest_xml:', manifest_xml)
    
    manifest_data = get_manifest_data(manifest_xml)
    print('manifest_data["packagename"]:', manifest_data['packagename'])
    print('manifest_data["application_name"]:', manifest_data['application_name'])
    print('manifest_data["mainactivity"]:', manifest_data['mainactivity'])
    
    manifest_data['file_md5'] = file_md5
    manifest_data['apk_path'] = apk_path
    return manifest_data

def init_environment(adb):
    #Proxy('', '', '', '')
    if SETTINGS.ANDROID_DYNAMIC_ANALYZER == "MobSF_REAL_DEVICE":
        print("\n[INFO] MobSF will perform Dynamic Analysis on real Android Device")
    elif SETTINGS.ANDROID_DYNAMIC_ANALYZER == "MobSF_AVD":
        # adb, avd_path, reference_name, dup_name, emulator
        refresh_avd(adb, SETTINGS.AVD_PATH, SETTINGS.AVD_REFERENCE_NAME,
                    SETTINGS.AVD_DUP_NAME, SETTINGS.AVD_EMULATOR)
    else:
        # Refersh VM
        refresh_vm(SETTINGS.UUID, SETTINGS.SUUID, SETTINGS.VBOX)
    return

def connect_device(adb):
    # AVD only needs to wait, vm needs the connect function
    if SETTINGS.ANDROID_DYNAMIC_ANALYZER == "MobSF_AVD":
        if not avd_load_wait(adb):
            print("\n[WARNING] ADB Load Wait Failed")
            exit()
    else:
        connect(DYNAMIC_TOOL_DIR)
    return

# monkey script 测试
def monkey_script_test(adb, app_info):
    monkey_script_pattern = '''
    type=user
    count=10
    speed=1.0
    start data >>
    captureDispatchPointer(0,0,0,200,600,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,200,600,1,1,-1,1,1,0,0)
    UserWait(1000)
    captureDispatchPointer(0,0,0,400,600,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,400,600,1,1,-1,1,1,0,0)
    UserWait(1000)
    captureDispatchPointer(0,0,0,600,600,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,600,600,1,1,-1,1,1,0,0)
    UserWait(1000)
    captureDispatchPointer(0,0,0,200,800,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,200,800,1,1,-1,1,1,0,0)
    UserWait(1000)
    captureDispatchPointer(0,0,0,600,1000,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,600,1000,1,1,-1,1,1,0,0)
    UserWait(3000)
    LaunchActivity({packagename}, {mainactivity})
    UserWait(5000)
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    Drag({screen_x_right},{screen_y_middle},{screen_x_left},{screen_y_middle},70)
    UserWait({drag_wait})
    captureDispatchPointer(0,0,0,{screen_x_middle},100,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},100,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},200,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},200,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},300,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},300,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},400,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},400,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},500,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},500,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},600,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},600,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},700,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},700,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},800,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},800,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},900,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},900,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},1000,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},1000,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},1100,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},1100,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,0,{screen_x_middle},1200,1,1,-1,1,1,0,0)
    captureDispatchPointer(0,0,1,{screen_x_middle},1200,1,1,-1,1,1,0,0)
    UserWait(1000)
    captureDispatchPress(4)
    captureDispatchPress(4)
    captureDispatchPress(4)
    '''
    drag_wait = 750
    packagename = app_info['packagename']
    mainactivity = app_info['mainactivity']
    if mainactivity.startswith('.'):
        mainactivity = packagename + mainactivity
    screen_x_right = 750
    screen_y_middle = 640
    screen_x_left = 50
    screen_x_middle = 400
    
    monkey_script_data = monkey_script_pattern.format(drag_wait=drag_wait, 
        packagename=packagename, mainactivity=mainactivity, 
        screen_x_right=screen_x_right, screen_y_middle=screen_y_middle, 
        screen_x_left=screen_x_left, screen_x_middle=screen_x_middle)
    
    monkey_script_file_name = os.path.join(os.path.dirname(app_info['apk_path']), 'monkey_script.txt')
    with open(monkey_script_file_name, 'w') as f:
        f.write(monkey_script_data)
    
    subprocess.call([adb,
                     "-s",
                     get_identifier(),
                     "push",
                     monkey_script_file_name,
                     "/data/local/tmp"])
    subprocess.call([adb,
                     "-s",
                     get_identifier(),
                     "shell",
                     "monkey", "-f", 
                     "/data/local/tmp/monkey_script.txt", "1"])
    print(u'\n[INFO] 跳过初始化界面')
    return

def auto_app_test(adb, app_info):
    print(u'\n[INFO] 开始自动化测试...')
    
    # monkey script 测试，用于进入初始化界面
    monkey_script_test(adb, app_info)
    
    packagename = app_info['packagename']
    # monkey 测试，输出太多，重定向输出
    p = subprocess.Popen([adb, '-s', get_identifier(), 'shell', 
                'monkey', '-p', packagename, 
                '--ignore-crashes', '--ignore-timeouts', 
                '--monitor-native-crashes', 
                '-v', '-v', '-v', '1000'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    # 设置超时检查
    start_time = time.time()
    while True:
        if p.poll() is not None:
            #useless_out, useless_err = p.communicate()
            break
        if time.time() - start_time > 60:
            p.terminate()
            break
        time.sleep(0.5)
    
    # TODO: 添加其他测试方法
    return


# 运行该 apk 文件，获取运行时特征并存储在 '该文件路径' + '_info_/' 目录中，
# 因此调用该函数时需要先检查以上目录是否存在，如果存在则认为已经运行过该 apk 文件。
def dynamic_main(file_path):
    
    # download_dir = ORIGIN_DOWNLOAD_DIR + app_info['file_md5'] + '/'
    
    try:
        file_md5 = genMD5(file_path)
        print('file_md5:', file_md5)
    
        app_info = get_static_info(file_path, file_md5)

        # 开始动态分析
        adb = getADB(DYNAMIC_TOOL_DIR)
        init_environment(adb)
        
        #set_web_proxy(app_info['file_md5'])
        
        connect_device(adb)
        
        
        # Change True to support non-activity components
        install_and_run(DYNAMIC_TOOL_DIR, app_info['apk_path'], app_info['packagename'], app_info['mainactivity'], True)

        # 开启下载 log 线程, 60s
        download_dir = os.path.dirname(os.path.dirname(app_info["apk_path"]))
        #t = start_strace(adb, download_dir, app_info['packagename'])
        t = start_download(adb, download_dir, app_info['packagename'])

        #time.sleep(40)
        #至少运行60s
        auto_app_test(adb, app_info)
        
        # 停止代理服务器，另一个线程会把网络传输数据保存到 UPLOAD_DIR 对应的文件夹中的 urls, WebTraffic.txt, requestdb 文件。
        #Proxy('', '', '', '')
        
        # 关闭下载 log 线程
        t.join()
        
        droidmon_log = os.path.join(download_dir, 'x_logcat.txt')
        droidmon_analysis(droidmon_log, app_info['packagename'])
        
        time.sleep(1)
        
        # 复制 apk 运行时访问的 url 到结果目录
        #shutil.copy(os.path.join(os.path.join(UPLOAD_DIR, app_info['file_md5']), 'urls'), os.path.join(download_dir, 'urls'))
        
        #result = analysis_x_logcat(download_dir + 'x_logcat.txt', app_info)
        #print(u'分析结果目录：', download_dir)
        # 由于临时文件比较大，当硬盘空间不足时，则删除临时文件，比如：UPLOAD_DIR, 
        shutil.rmtree(os.path.dirname(app_info['apk_path']), ignore_errors=True)
        return 1
    except Exception as e:
        result = {}
        # Install Error           表示安装 apk 文件时报错。
        # Parsing Manifest Error  表示解析 AndroidManifest.xml 文件时报错。
        print(traceback.format_exc())
    #shutil.rmtree(os.path.dirname(app_info['apk_path']))
    return 0
    
    #return result

def get_features_from_dir(dir_path):
    run_times = 0
    run_succ = 0
    for root, dirs, files in os.walk(dir_path):
        if root.endswith('_info_') or root.endswith("_info"):
            continue
        for name in files:
            file_name = os.path.join(root, name)
            droidmon_file = os.path.join(file_name+"_info", "droidmon_out.txt")

            print(u'%s>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>正在运行第%s个文件\n%s'%(time.asctime(time.localtime(time.time())), run_times, file_name))

            if(os.path.exists(droidmon_file)):
                print("droidmon_file exists: ", droidmon_file)
                run_times = run_times + 1
                run_succ = run_succ + 1
            else:
                run_times = run_times + 1
                run_succ = run_succ + dynamic_main(file_name)
                if DEBUGING:
                    if run_times == DEBUGING_NUMS:
                        return
            print(u'<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<第%s个文件运行完毕%s, 成功：%s个, 成功率： %s'%(run_times, file_name, run_succ, run_succ*1.0/run_times))
    return

def analysis_strace(dir_path):
    app_count = 0
    strace_count = 0
    sclens = []
    for root, dirs, files in os.walk(dir_path):
        if(root.endswith('_info_')) or root.endswith("_info"):
            continue
        for name in files:
            file_name = os.path.join(root, name)
            systemcall_file = os.path.join(file_name+"_info", "systemcall.txt")
            if (os.path.exists(file_name)):
                app_count += 1
            if (os.path.exists(systemcall_file)):
                print(systemcall_file)
                strace_count += 1
                to_file = os.path.join(file_name+"_info", "parsed_systemcall.txt")
                sclen = strace_analysis(systemcall_file, to_file)
                sclens.append(sclen)

    import json
    fw = open(os.path.join(dir_path, "sclen.txt"), 'w', encoding="utf-8")
    json.dump(sclens, fw)
    print(sclens)


def print_x_log_analysis_result(result):
    print(u'\n检测到敏感行为：')
    print(json.dumps(result['sensitives'], indent=4, ensure_ascii=False))
    
    print(u'\n检测到漏洞：')
    print(json.dumps(result['vulnerabilities'], indent=4, ensure_ascii=False))
    return

def test_dynamic():
    print(u'请输入被检测apk文件的绝对路径：')
    file_path = raw_input()
    if file_path.startswith('"') and file_path.endswith('"'):
        file_path = file_path[1:-1]
    print('file_path:', file_path)
    result = dynamic_main(file_path)
    print_x_log_analysis_result(result)
    return

def test_get_features(func):
    print(u'请输入包含apk文件的目录绝对路径：')
    #dir_path = u'M:\\Android_Samples\\android_malware\Android_benign\\360shoujizhushou\\2017-12-10--2017-12-11'
    #print(dir_path)
    dir_path = input()
    if dir_path.startswith('"') and dir_path.endswith('"'):
        dir_path = dir_path[1:-1]
    print('dir_path:', dir_path)
    func(dir_path)
    print("目录分析finsh")
    return

if __name__ == '__main__':
    try:
        # test_dynamic()
        # generate systemcall.txt
        test_get_features(get_features_from_dir)
        #generate parsed_systemcall.txt
        #test_get_features(analysis_strace)
    except Exception as err:
        print(traceback.format_exc())
    os.kill(os.getpid(), signal.SIGTERM)
